var WPQuery=function(){"use strict";function _defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||!1,descriptor.configurable=!0,"value"in descriptor&&(descriptor.writable=!0),Object.defineProperty(target,descriptor.key,descriptor)}}var bind=function(fn,thisArg){return function(){for(var args=new Array(arguments.length),i=0;i<args.length;i++)args[i]=arguments[i];return fn.apply(thisArg,args)}},toString=Object.prototype.toString;
/*global toString:true*/
// utils is a library of generic helper functions non-specific to axios
/**
   * Determine if a value is an Array
   *
   * @param {Object} val The value to test
   * @returns {boolean} True if value is an Array, otherwise false
   */
function isArray(val){return"[object Array]"===toString.call(val)}
/**
   * Determine if a value is undefined
   *
   * @param {Object} val The value to test
   * @returns {boolean} True if the value is undefined, otherwise false
   */function isUndefined(val){return void 0===val}
/**
   * Determine if a value is a Buffer
   *
   * @param {Object} val The value to test
   * @returns {boolean} True if value is a Buffer, otherwise false
   */
/**
   * Determine if a value is an Object
   *
   * @param {Object} val The value to test
   * @returns {boolean} True if value is an Object, otherwise false
   */
function isObject(val){return null!==val&&"object"==typeof val}
/**
   * Determine if a value is a Date
   *
   * @param {Object} val The value to test
   * @returns {boolean} True if value is a Date, otherwise false
   */
/**
   * Determine if a value is a Function
   *
   * @param {Object} val The value to test
   * @returns {boolean} True if value is a Function, otherwise false
   */
function isFunction(val){return"[object Function]"===toString.call(val)}
/**
   * Determine if a value is a Stream
   *
   * @param {Object} val The value to test
   * @returns {boolean} True if value is a Stream, otherwise false
   */
/**
   * Iterate over an Array or an Object invoking a function for each item.
   *
   * If `obj` is an Array callback will be called passing
   * the value, index, and complete array for each item.
   *
   * If 'obj' is an Object callback will be called passing
   * the value, key, and complete object for each property.
   *
   * @param {Object|Array} obj The object to iterate
   * @param {Function} fn The callback to invoke for each item
   */
function forEach(obj,fn){
// Don't bother if no value provided
if(null!=obj)if(
// Force an array if not already something iterable
"object"!=typeof obj&&(
/*eslint no-param-reassign:0*/
obj=[obj]),isArray(obj))
// Iterate over array values
for(var i=0,l=obj.length;i<l;i++)fn.call(null,obj[i],i,obj);else
// Iterate over object keys
for(var key in obj)Object.prototype.hasOwnProperty.call(obj,key)&&fn.call(null,obj[key],key,obj)}
/**
   * Accepts varargs expecting each argument to be an object, then
   * immutably merges the properties of each object and returns result.
   *
   * When multiple objects contain the same key the later object in
   * the arguments list will take precedence.
   *
   * Example:
   *
   * ```js
   * var result = merge({foo: 123}, {foo: 456});
   * console.log(result.foo); // outputs 456
   * ```
   *
   * @param {Object} obj1 Object to merge
   * @returns {Object} Result of all merge properties
   */var utils={isArray:isArray,isArrayBuffer:
/**
   * Determine if a value is an ArrayBuffer
   *
   * @param {Object} val The value to test
   * @returns {boolean} True if value is an ArrayBuffer, otherwise false
   */
function(val){return"[object ArrayBuffer]"===toString.call(val)}
/**
   * Determine if a value is a FormData
   *
   * @param {Object} val The value to test
   * @returns {boolean} True if value is an FormData, otherwise false
   */,isBuffer:function(val){return null!==val&&!isUndefined(val)&&null!==val.constructor&&!isUndefined(val.constructor)&&"function"==typeof val.constructor.isBuffer&&val.constructor.isBuffer(val)},isFormData:function(val){return"undefined"!=typeof FormData&&val instanceof FormData}
/**
   * Determine if a value is a view on an ArrayBuffer
   *
   * @param {Object} val The value to test
   * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
   */,isArrayBufferView:function(val){return"undefined"!=typeof ArrayBuffer&&ArrayBuffer.isView?ArrayBuffer.isView(val):val&&val.buffer&&val.buffer instanceof ArrayBuffer}
/**
   * Determine if a value is a String
   *
   * @param {Object} val The value to test
   * @returns {boolean} True if value is a String, otherwise false
   */,isString:function(val){return"string"==typeof val}
/**
   * Determine if a value is a Number
   *
   * @param {Object} val The value to test
   * @returns {boolean} True if value is a Number, otherwise false
   */,isNumber:function(val){return"number"==typeof val},isObject:isObject,isUndefined:isUndefined,isDate:function(val){return"[object Date]"===toString.call(val)}
/**
   * Determine if a value is a File
   *
   * @param {Object} val The value to test
   * @returns {boolean} True if value is a File, otherwise false
   */,isFile:function(val){return"[object File]"===toString.call(val)}
/**
   * Determine if a value is a Blob
   *
   * @param {Object} val The value to test
   * @returns {boolean} True if value is a Blob, otherwise false
   */,isBlob:function(val){return"[object Blob]"===toString.call(val)},isFunction:isFunction,isStream:function(val){return isObject(val)&&isFunction(val.pipe)}
/**
   * Determine if a value is a URLSearchParams object
   *
   * @param {Object} val The value to test
   * @returns {boolean} True if value is a URLSearchParams object, otherwise false
   */,isURLSearchParams:function(val){return"undefined"!=typeof URLSearchParams&&val instanceof URLSearchParams}
/**
   * Trim excess whitespace off the beginning and end of a string
   *
   * @param {String} str The String to trim
   * @returns {String} The String freed of excess whitespace
   */,isStandardBrowserEnv:
/**
   * Determine if we're running in a standard browser environment
   *
   * This allows axios to run in a web worker, and react-native.
   * Both environments support XMLHttpRequest, but not fully standard globals.
   *
   * web workers:
   *  typeof window -> undefined
   *  typeof document -> undefined
   *
   * react-native:
   *  navigator.product -> 'ReactNative'
   * nativescript
   *  navigator.product -> 'NativeScript' or 'NS'
   */
function(){return("undefined"==typeof navigator||"ReactNative"!==navigator.product&&"NativeScript"!==navigator.product&&"NS"!==navigator.product)&&("undefined"!=typeof window&&"undefined"!=typeof document)},forEach:forEach,merge:function merge(){var result={};function assignValue(val,key){"object"==typeof result[key]&&"object"==typeof val?result[key]=merge(result[key],val):result[key]=val}for(var i=0,l=arguments.length;i<l;i++)forEach(arguments[i],assignValue);return result}
/**
   * Function equal to merge with the difference being that no reference
   * to original objects is kept.
   *
   * @see merge
   * @param {Object} obj1 Object to merge
   * @returns {Object} Result of all merge properties
   */,deepMerge:function deepMerge(){var result={};function assignValue(val,key){"object"==typeof result[key]&&"object"==typeof val?result[key]=deepMerge(result[key],val):result[key]="object"==typeof val?deepMerge({},val):val}for(var i=0,l=arguments.length;i<l;i++)forEach(arguments[i],assignValue);return result}
/**
   * Extends object a by mutably adding to it the properties of object b.
   *
   * @param {Object} a The object to be extended
   * @param {Object} b The object to copy properties from
   * @param {Object} thisArg The object to bind function to
   * @return {Object} The resulting value of object a
   */,extend:function(a,b,thisArg){return forEach(b,(function(val,key){a[key]=thisArg&&"function"==typeof val?bind(val,thisArg):val})),a},trim:function(str){return str.replace(/^\s*/,"").replace(/\s*$/,"")}};function encode(val){return encodeURIComponent(val).replace(/%40/gi,"@").replace(/%3A/gi,":").replace(/%24/g,"$").replace(/%2C/gi,",").replace(/%20/g,"+").replace(/%5B/gi,"[").replace(/%5D/gi,"]")}
/**
   * Build a URL by appending params to the end
   *
   * @param {string} url The base of the url (e.g., http://www.google.com)
   * @param {object} [params] The params to be appended
   * @returns {string} The formatted url
   */var buildURL=function(url,params,paramsSerializer){
/*eslint no-param-reassign:0*/
if(!params)return url;var serializedParams;if(paramsSerializer)serializedParams=paramsSerializer(params);else if(utils.isURLSearchParams(params))serializedParams=params.toString();else{var parts=[];utils.forEach(params,(function(val,key){null!=val&&(utils.isArray(val)?key+="[]":val=[val],utils.forEach(val,(function(v){utils.isDate(v)?v=v.toISOString():utils.isObject(v)&&(v=JSON.stringify(v)),parts.push(encode(key)+"="+encode(v))})))})),serializedParams=parts.join("&")}if(serializedParams){var hashmarkIndex=url.indexOf("#");-1!==hashmarkIndex&&(url=url.slice(0,hashmarkIndex)),url+=(-1===url.indexOf("?")?"?":"&")+serializedParams}return url};function InterceptorManager(){this.handlers=[]}
/**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */InterceptorManager.prototype.use=function(fulfilled,rejected){return this.handlers.push({fulfilled:fulfilled,rejected:rejected}),this.handlers.length-1},
/**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   */
InterceptorManager.prototype.eject=function(id){this.handlers[id]&&(this.handlers[id]=null)},
/**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   */
InterceptorManager.prototype.forEach=function(fn){utils.forEach(this.handlers,(function(h){null!==h&&fn(h)}))};var InterceptorManager_1=InterceptorManager,transformData=function(data,headers,fns){
/*eslint no-param-reassign:0*/
return utils.forEach(fns,(function(fn){data=fn(data,headers)})),data},isCancel=function(value){return!(!value||!value.__CANCEL__)},normalizeHeaderName=function(headers,normalizedName){utils.forEach(headers,(function(value,name){name!==normalizedName&&name.toUpperCase()===normalizedName.toUpperCase()&&(headers[normalizedName]=value,delete headers[name])}))},createError=function(message,config,code,request,response){return function(error,config,code,request,response){return error.config=config,code&&(error.code=code),error.request=request,error.response=response,error.isAxiosError=!0,error.toJSON=function(){return{
// Standard
message:this.message,name:this.name,
// Microsoft
description:this.description,number:this.number,
// Mozilla
fileName:this.fileName,lineNumber:this.lineNumber,columnNumber:this.columnNumber,stack:this.stack,
// Axios
config:this.config,code:this.code}},error}(new Error(message),config,code,request,response)},ignoreDuplicateOf=["age","authorization","content-length","content-type","etag","expires","from","host","if-modified-since","if-unmodified-since","last-modified","location","max-forwards","proxy-authorization","referer","retry-after","user-agent"],isURLSameOrigin=utils.isStandardBrowserEnv()?
// Standard browser envs have full support of the APIs needed to test
// whether the request URL is of the same origin as current location.
function(){var originURL,msie=/(msie|trident)/i.test(navigator.userAgent),urlParsingNode=document.createElement("a");
/**
      * Parse a URL to discover it's components
      *
      * @param {String} url The URL to be parsed
      * @returns {Object}
      */
function resolveURL(url){var href=url;
// urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils
return msie&&(
// IE needs attribute set twice to normalize properties
urlParsingNode.setAttribute("href",href),href=urlParsingNode.href),urlParsingNode.setAttribute("href",href),{href:urlParsingNode.href,protocol:urlParsingNode.protocol?urlParsingNode.protocol.replace(/:$/,""):"",host:urlParsingNode.host,search:urlParsingNode.search?urlParsingNode.search.replace(/^\?/,""):"",hash:urlParsingNode.hash?urlParsingNode.hash.replace(/^#/,""):"",hostname:urlParsingNode.hostname,port:urlParsingNode.port,pathname:"/"===urlParsingNode.pathname.charAt(0)?urlParsingNode.pathname:"/"+urlParsingNode.pathname}}
/**
      * Determine if a URL shares the same origin as the current location
      *
      * @param {String} requestURL The URL to test
      * @returns {boolean} True if URL shares the same origin, otherwise false
      */
return originURL=resolveURL(window.location.href),function(requestURL){var parsed=utils.isString(requestURL)?resolveURL(requestURL):requestURL;return parsed.protocol===originURL.protocol&&parsed.host===originURL.host}}():function(){return!0},cookies=utils.isStandardBrowserEnv()?{write:function(name,value,expires,path,domain,secure){var cookie=[];cookie.push(name+"="+encodeURIComponent(value)),utils.isNumber(expires)&&cookie.push("expires="+new Date(expires).toGMTString()),utils.isString(path)&&cookie.push("path="+path),utils.isString(domain)&&cookie.push("domain="+domain),!0===secure&&cookie.push("secure"),document.cookie=cookie.join("; ")},read:function(name){var match=document.cookie.match(new RegExp("(^|;\\s*)("+name+")=([^;]*)"));return match?decodeURIComponent(match[3]):null},remove:function(name){this.write(name,"",Date.now()-864e5)}}:{write:function(){},read:function(){return null},remove:function(){}},xhr=function(config){return new Promise((function(resolve,reject){var requestData=config.data,requestHeaders=config.headers;utils.isFormData(requestData)&&delete requestHeaders["Content-Type"];var request=new XMLHttpRequest;
// HTTP basic authentication
if(config.auth){var username=config.auth.username||"",password=config.auth.password||"";requestHeaders.Authorization="Basic "+btoa(username+":"+password)}var baseURL,requestedURL,fullPath=(baseURL=config.baseURL,requestedURL=config.url,baseURL&&!/^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(requestedURL)?function(baseURL,relativeURL){return relativeURL?baseURL.replace(/\/+$/,"")+"/"+relativeURL.replace(/^\/+/,""):baseURL}(baseURL,requestedURL):requestedURL);
// Add xsrf header
// This is only done if running in a standard browser environment.
// Specifically not if we're in a web worker, or react-native.
if(request.open(config.method.toUpperCase(),buildURL(fullPath,config.params,config.paramsSerializer),!0),
// Set the request timeout in MS
request.timeout=config.timeout,
// Listen for ready state
request.onreadystatechange=function(){if(request&&4===request.readyState&&(0!==request.status||request.responseURL&&0===request.responseURL.indexOf("file:")))
// The request errored out and we didn't get a response, this will be
// handled by onerror instead
// With one exception: request that using file: protocol, most browsers
// will return status as 0 even though it's a successful request
{
// Prepare the response
var headers,key,val,i,parsed,responseHeaders="getAllResponseHeaders"in request?(headers=request.getAllResponseHeaders(),parsed={},headers?(utils.forEach(headers.split("\n"),(function(line){if(i=line.indexOf(":"),key=utils.trim(line.substr(0,i)).toLowerCase(),val=utils.trim(line.substr(i+1)),key){if(parsed[key]&&ignoreDuplicateOf.indexOf(key)>=0)return;parsed[key]="set-cookie"===key?(parsed[key]?parsed[key]:[]).concat([val]):parsed[key]?parsed[key]+", "+val:val}})),parsed):parsed):null,response={data:config.responseType&&"text"!==config.responseType?request.response:request.responseText,status:request.status,statusText:request.statusText,headers:responseHeaders,config:config,request:request};!function(resolve,reject,response){var validateStatus=response.config.validateStatus;!validateStatus||validateStatus(response.status)?resolve(response):reject(createError("Request failed with status code "+response.status,response.config,null,response.request,response))}(resolve,reject,response),
// Clean up request
request=null}},
// Handle browser request cancellation (as opposed to a manual cancellation)
request.onabort=function(){request&&(reject(createError("Request aborted",config,"ECONNABORTED",request)),
// Clean up request
request=null)},
// Handle low level network errors
request.onerror=function(){
// Real errors are hidden from us by the browser
// onerror should only fire if it's a network error
reject(createError("Network Error",config,null,request)),
// Clean up request
request=null},
// Handle timeout
request.ontimeout=function(){var timeoutErrorMessage="timeout of "+config.timeout+"ms exceeded";config.timeoutErrorMessage&&(timeoutErrorMessage=config.timeoutErrorMessage),reject(createError(timeoutErrorMessage,config,"ECONNABORTED",request)),
// Clean up request
request=null},utils.isStandardBrowserEnv()){var cookies$1=cookies,xsrfValue=(config.withCredentials||isURLSameOrigin(fullPath))&&config.xsrfCookieName?cookies$1.read(config.xsrfCookieName):void 0;
// Add xsrf header
xsrfValue&&(requestHeaders[config.xsrfHeaderName]=xsrfValue)}
// Add headers to the request
// Add responseType to request if needed
if("setRequestHeader"in request&&utils.forEach(requestHeaders,(function(val,key){void 0===requestData&&"content-type"===key.toLowerCase()?
// Remove Content-Type if data is undefined
delete requestHeaders[key]:
// Otherwise add header to the request
request.setRequestHeader(key,val)})),
// Add withCredentials to request if needed
utils.isUndefined(config.withCredentials)||(request.withCredentials=!!config.withCredentials),config.responseType)try{request.responseType=config.responseType}catch(e){
// Expected DOMException thrown by browsers not compatible XMLHttpRequest Level 2.
// But, this can be suppressed for 'json' type as it can be parsed by default 'transformResponse' function.
if("json"!==config.responseType)throw e}
// Handle progress if needed
"function"==typeof config.onDownloadProgress&&request.addEventListener("progress",config.onDownloadProgress),
// Not all browsers support upload events
"function"==typeof config.onUploadProgress&&request.upload&&request.upload.addEventListener("progress",config.onUploadProgress),config.cancelToken&&
// Handle cancellation
config.cancelToken.promise.then((function(cancel){request&&(request.abort(),reject(cancel),
// Clean up request
request=null)})),void 0===requestData&&(requestData=null),
// Send the request
request.send(requestData)}))},DEFAULT_CONTENT_TYPE={"Content-Type":"application/x-www-form-urlencoded"};
/**
   * Transform the data for a request or a response
   *
   * @param {Object|String} data The data to be transformed
   * @param {Array} headers The headers for the request or response
   * @param {Array|Function} fns A single function or Array of functions
   * @returns {*} The resulting transformed data
   */function setContentTypeIfUnset(headers,value){!utils.isUndefined(headers)&&utils.isUndefined(headers["Content-Type"])&&(headers["Content-Type"]=value)}var adapter,defaults={adapter:("undefined"!=typeof XMLHttpRequest?
// For browsers use XHR adapter
adapter=xhr:"undefined"!=typeof process&&"[object process]"===Object.prototype.toString.call(process)&&(
// For node use HTTP adapter
adapter=xhr),adapter),transformRequest:[function(data,headers){return normalizeHeaderName(headers,"Accept"),normalizeHeaderName(headers,"Content-Type"),utils.isFormData(data)||utils.isArrayBuffer(data)||utils.isBuffer(data)||utils.isStream(data)||utils.isFile(data)||utils.isBlob(data)?data:utils.isArrayBufferView(data)?data.buffer:utils.isURLSearchParams(data)?(setContentTypeIfUnset(headers,"application/x-www-form-urlencoded;charset=utf-8"),data.toString()):utils.isObject(data)?(setContentTypeIfUnset(headers,"application/json;charset=utf-8"),JSON.stringify(data)):data}],transformResponse:[function(data){
/*eslint no-param-reassign:0*/
if("string"==typeof data)try{data=JSON.parse(data)}catch(e){/* Ignore */}return data}],
/**
     * A timeout in milliseconds to abort a request. If set to 0 (default) a
     * timeout is not created.
     */
timeout:0,xsrfCookieName:"XSRF-TOKEN",xsrfHeaderName:"X-XSRF-TOKEN",maxContentLength:-1,validateStatus:function(status){return status>=200&&status<300}};defaults.headers={common:{Accept:"application/json, text/plain, */*"}},utils.forEach(["delete","get","head"],(function(method){defaults.headers[method]={}})),utils.forEach(["post","put","patch"],(function(method){defaults.headers[method]=utils.merge(DEFAULT_CONTENT_TYPE)}));var defaults_1=defaults;
/**
   * Throws a `Cancel` if cancellation has been requested.
   */function throwIfCancellationRequested(config){config.cancelToken&&config.cancelToken.throwIfRequested()}
/**
   * Dispatch a request to the server using the configured adapter.
   *
   * @param {object} config The config that is to be used for the request
   * @returns {Promise} The Promise to be fulfilled
   */var dispatchRequest=function(config){return throwIfCancellationRequested(config),
// Ensure headers exist
config.headers=config.headers||{},
// Transform request data
config.data=transformData(config.data,config.headers,config.transformRequest),
// Flatten headers
config.headers=utils.merge(config.headers.common||{},config.headers[config.method]||{},config.headers),utils.forEach(["delete","get","head","post","put","patch","common"],(function(method){delete config.headers[method]})),(config.adapter||defaults_1.adapter)(config).then((function(response){return throwIfCancellationRequested(config),
// Transform response data
response.data=transformData(response.data,response.headers,config.transformResponse),response}),(function(reason){return isCancel(reason)||(throwIfCancellationRequested(config),
// Transform response data
reason&&reason.response&&(reason.response.data=transformData(reason.response.data,reason.response.headers,config.transformResponse))),Promise.reject(reason)}))},mergeConfig=function(config1,config2){
// eslint-disable-next-line no-param-reassign
config2=config2||{};var config={},valueFromConfig2Keys=["url","method","params","data"],mergeDeepPropertiesKeys=["headers","auth","proxy"],defaultToConfig2Keys=["baseURL","url","transformRequest","transformResponse","paramsSerializer","timeout","withCredentials","adapter","responseType","xsrfCookieName","xsrfHeaderName","onUploadProgress","onDownloadProgress","maxContentLength","validateStatus","maxRedirects","httpAgent","httpsAgent","cancelToken","socketPath"];utils.forEach(valueFromConfig2Keys,(function(prop){void 0!==config2[prop]&&(config[prop]=config2[prop])})),utils.forEach(mergeDeepPropertiesKeys,(function(prop){utils.isObject(config2[prop])?config[prop]=utils.deepMerge(config1[prop],config2[prop]):void 0!==config2[prop]?config[prop]=config2[prop]:utils.isObject(config1[prop])?config[prop]=utils.deepMerge(config1[prop]):void 0!==config1[prop]&&(config[prop]=config1[prop])})),utils.forEach(defaultToConfig2Keys,(function(prop){void 0!==config2[prop]?config[prop]=config2[prop]:void 0!==config1[prop]&&(config[prop]=config1[prop])}));var axiosKeys=valueFromConfig2Keys.concat(mergeDeepPropertiesKeys).concat(defaultToConfig2Keys),otherKeys=Object.keys(config2).filter((function(key){return-1===axiosKeys.indexOf(key)}));return utils.forEach(otherKeys,(function(prop){void 0!==config2[prop]?config[prop]=config2[prop]:void 0!==config1[prop]&&(config[prop]=config1[prop])})),config};
/**
   * Config-specific merge-function which creates a new config-object
   * by merging two configuration objects together.
   *
   * @param {Object} config1
   * @param {Object} config2
   * @returns {Object} New object resulting from merging config2 to config1
   */
/**
   * Create a new instance of Axios
   *
   * @param {Object} instanceConfig The default config for the instance
   */
function Axios(instanceConfig){this.defaults=instanceConfig,this.interceptors={request:new InterceptorManager_1,response:new InterceptorManager_1}}
/**
   * Dispatch a request
   *
   * @param {Object} config The config specific for this request (merged with this.defaults)
   */Axios.prototype.request=function(config){
/*eslint no-param-reassign:0*/
// Allow for axios('example/url'[, config]) a la fetch API
"string"==typeof config?(config=arguments[1]||{}).url=arguments[0]:config=config||{},
// Set config.method
(config=mergeConfig(this.defaults,config)).method?config.method=config.method.toLowerCase():this.defaults.method?config.method=this.defaults.method.toLowerCase():config.method="get";
// Hook up interceptors middleware
var chain=[dispatchRequest,void 0],promise=Promise.resolve(config);for(this.interceptors.request.forEach((function(interceptor){chain.unshift(interceptor.fulfilled,interceptor.rejected)})),this.interceptors.response.forEach((function(interceptor){chain.push(interceptor.fulfilled,interceptor.rejected)}));chain.length;)promise=promise.then(chain.shift(),chain.shift());return promise},Axios.prototype.getUri=function(config){return config=mergeConfig(this.defaults,config),buildURL(config.url,config.params,config.paramsSerializer).replace(/^\?/,"")},
// Provide aliases for supported request methods
utils.forEach(["delete","get","head","options"],(function(method){
/*eslint func-names:0*/
Axios.prototype[method]=function(url,config){return this.request(utils.merge(config||{},{method:method,url:url}))}})),utils.forEach(["post","put","patch"],(function(method){
/*eslint func-names:0*/
Axios.prototype[method]=function(url,data,config){return this.request(utils.merge(config||{},{method:method,url:url,data:data}))}}));var Axios_1=Axios;
/**
   * A `Cancel` is an object that is thrown when an operation is canceled.
   *
   * @class
   * @param {string=} message The message.
   */function Cancel(message){this.message=message}Cancel.prototype.toString=function(){return"Cancel"+(this.message?": "+this.message:"")},Cancel.prototype.__CANCEL__=!0;var Cancel_1=Cancel;
/**
   * A `CancelToken` is an object that can be used to request cancellation of an operation.
   *
   * @class
   * @param {Function} executor The executor function.
   */function CancelToken(executor){if("function"!=typeof executor)throw new TypeError("executor must be a function.");var resolvePromise;this.promise=new Promise((function(resolve){resolvePromise=resolve}));var token=this;executor((function(message){token.reason||(token.reason=new Cancel_1(message),resolvePromise(token.reason))}))}
/**
   * Throws a `Cancel` if cancellation has been requested.
   */CancelToken.prototype.throwIfRequested=function(){if(this.reason)throw this.reason},
/**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
CancelToken.source=function(){var cancel;return{token:new CancelToken((function(c){cancel=c})),cancel:cancel}};var CancelToken_1=CancelToken;
/**
   * Syntactic sugar for invoking a function and expanding an array for arguments.
   *
   * Common use case would be to use `Function.prototype.apply`.
   *
   *  ```js
   *  function f(x, y, z) {}
   *  var args = [1, 2, 3];
   *  f.apply(null, args);
   *  ```
   *
   * With `spread` this example can be re-written.
   *
   *  ```js
   *  spread(function(x, y, z) {})([1, 2, 3]);
   *  ```
   *
   * @param {Function} callback
   * @returns {Function}
   */
/**
   * Create an instance of Axios
   *
   * @param {Object} defaultConfig The default config for the instance
   * @return {Axios} A new instance of Axios
   */
function createInstance(defaultConfig){var context=new Axios_1(defaultConfig),instance=bind(Axios_1.prototype.request,context);
// Copy axios.prototype to instance
return utils.extend(instance,Axios_1.prototype,context),
// Copy context to instance
utils.extend(instance,context),instance}
// Create the default instance to be exported
var axios=createInstance(defaults_1);
// Expose Axios class to allow class inheritance
axios.Axios=Axios_1,
// Factory for creating new instances
axios.create=function(instanceConfig){return createInstance(mergeConfig(axios.defaults,instanceConfig))},
// Expose Cancel & CancelToken
axios.Cancel=Cancel_1,axios.CancelToken=CancelToken_1,axios.isCancel=isCancel,
// Expose all/spread
axios.all=function(promises){return Promise.all(promises)},axios.spread=function(callback){return function(arr){return callback.apply(null,arr)}};var axios_1=axios,default_1=axios;
// Allow use of default import syntax in TypeScript
axios_1.default=default_1;var axios$1=axios_1;

return function(){function WPQuery(baseURL){!function(instance,Constructor){if(!(instance instanceof Constructor))throw new TypeError("Cannot call a class as a function")}(this,WPQuery),this._baseURL=baseURL}var Constructor,protoProps,staticProps;return Constructor=WPQuery,(protoProps=[{key:"request",value:function(method){var _this=this,resource=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"posts",params=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},globals=["fields","embed","method","envelope","jsonp"],string="/wp-json/wp/v2/".concat(resource);return params.id&&(string+="/".concat(params.id,"/")),string+="?",Object.keys(params).forEach((function(element){var param=element.replace(/\.?([A-Z]+)/g,(function(x,y){return"_".concat(y.toLowerCase())})).replace(/^_/,"");globals.includes(element)&&(param="_".concat(param)),Array.isArray(params[element])?string+="&".concat(param,"=").concat(params[element].join()):"id"!==element&&(string+="&".concat(param,"=").concat(params[element]))})),new Promise((function(resolve,reject){axios$1[method](_this._baseURL+string).then((function(response){return resolve(response)})).catch((function(error){return reject(error.response)}))}))}},{key:"get",value:function(resource,params){return this.request("get",resource,params)}}])&&_defineProperties(Constructor.prototype,protoProps),staticProps&&_defineProperties(Constructor,staticProps),WPQuery}()}();
//# sourceMappingURL=WPQuery.js.map